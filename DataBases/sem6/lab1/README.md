# Инструкция по работе с проектом

Этот проект демонстрирует использование PostgreSQL: создание индексов, транзакции, работа с расширениями (`pg_trgm`, `pg_bigm`, `pgcrypto`) и загрузка реальных данных из Kaggle.

## 1. Поднятие базы данных и заполнение её данными

### 1.1. Создание Docker-образа PostgreSQL с установленными расширениями

Для запуска контейнера с базой данных выполните следующую команду из корня проекта:

```bash
docker-compose up --build
```

### 1.2. Скачивание датасета с Kaggle

#### 1.2.1. Ссылка на датасет, использованный в проекте:

```
[Датасет с Kaggle](https://www.kaggle.com/datasets/mkechinov/ecommerce-behavior-data-from-multi-category-store)
```

Вы также можете использовать любой другой датасет, соответствующий требованиям лабораторной работы.

#### 1.2.2. Подготовка датасета:

* Распакуйте скачанный архив.
* Поместите файл с данными в папку `dataset/`.
* Переименуйте файл в `downloaded_dataset.csv`.

### 1.3. Генерация пользователей

Для генерации пользовательских данных выполните:

```bash
python dataset_combinating_scripts/generate_users.py
```

### 1.4. Заполнение базы данных

Для импорта данных в базу данных выполните:

```bash
python dataset_combinating_scripts/fill_db.py
```

## 2. Работа с индексами

### 2.1. Создание индексов

* Откройте файл `cmd/p1/indexes.py`.
* Выберите мод `create-indexes` (просто записав его в `default`).
* Из корня проекта выполните команду:
    ```
    python -m cmd.p1.indexes
    ```
### 2.2. Запуск бенчмарков:

Без использования индексов:
* В файле `cmd/p1/indexes.py` выберите режим `benchmark-noindex`.
* Из корня проекта выполните команду:
    ```
    python -m cmd.p1.indexes
    ```

С использованием индексов:
* В файле `cmd/p1/indexes.py` выберите режим `benchmark-index`.
* Из корня проекта выполните команду:
    ```
    python -m cmd.p1.indexes
    ```
### 2.3. Изменение запросов

SQL-запросы можно изменять в `internal/db/store_1.py`. Например:

```
-- Было:
SELECT COUNT(*) FROM products WHERE price BETWEEN 250 AND 500;

-- Можно заменить на:
SELECT COUNT(*) FROM products WHERE price BETWEEN 300 AND 700;
```

Или изменять диапазон дат:

```
SELECT COUNT(*) FROM orders WHERE order_date BETWEEN '2019-11-03' AND '2019-11-04';
```

## 3. Транзакции и аномалии

В этом разделе демонстрируется поведение различных уровней изоляции транзакций в PostgreSQL: `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE`. Также наглядно показываются типичные аномалии, возникающие при недостаточной изоляции: **non-repeatable read** и **phantom read**.

### 3.1. Доступные режимы

Для запуска используйте:

```bash
python -m cmd.p2.transactions --mode <режим>
```

Поддерживаемые режимы:

#### `Serializable`

* Демонстрирует самый строгий уровень изоляции.
* Проводится покупка товара (`place_order`) и пополнение его остатка на складе (`restock_product`) в рамках одной транзакции.
* Используется `SERIALIZABLE`, чтобы обеспечить целостность данных и избежать конфликтов при параллельной работе.

#### `Repeatable Read`

* Выполняется перевод средств между пользователями (`transfer_funds`) с уровнем `REPEATABLE READ`.
* Блокировка строк выполняется в **порядке возрастания `user_id`**, чтобы избежать взаимоблокировок (deadlocks).
* Гарантируется, что данные, прочитанные в начале транзакции, не будут изменены другими до её завершения.

#### `Non‑Repeatable Read`

* Демонстрирует проблему **"неповторяемого чтения"**.
* Два потока (транзакции):
  * `Tx1` дважды читает цену продукта.
  * `Tx2` между чтениями меняет цену.
* В результате `Tx1` видит **разные значения в рамках одной транзакции**, что возможно при `READ COMMITTED`.

#### `Phantom Read`

* Демонстрирует проблему **"фантомных записей"**.
* `Tx1` делает два подсчета заказов по продукту.
* Между подсчетами `Tx2` добавляет новый заказ.
* В результате `Tx1` видит **разное количество строк**, хотя не модифицировал данные — это и есть фантомное чтение.

### 3.2. Где реализована логика

* Транзакции: `internal/db/store_2.py`
* Демонстрации аномалий (в два потока): `internal/db/anomalyes_2.py`
* Точка входа: `cmd/p2/transactions.py`

## 4. Расширения PostgreSQL

* Откройте файл `cmd/p3/extensions.py`.
* Из корня проекта выполните команду:
    ```
    python -m cmd.p3.extensions
    ```

При запуске `cmd/p3/extensions.py` создается таблица `encrypted_users`, в которую копируются и шифруются email пользователей с использованием `pgcrypto`. Это демонстрирует защиту персональных данных.

Этот скрипт демонстрирует использование расширений PostgreSQL (`pg_trgm`, `pg_bigm`, `pgcrypto`) для:
- нечеткого поиска производителей и категорий продуктов,
- шифрования и дешифрования email-адресов пользователей.

Файл с реализацией расширений: `internal/db/extensions_3.py`.