package org.example;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class Main extends JPanel {

    static class Point {
        double x, y;
        Point(double x, double y) { this.x = x; this.y = y; }
    }


    // массив точек по заданию
    static Point[] points = {
            new Point(0.1, 100.01),
            new Point(0.5, 4.25),
            new Point(0.9, 2.0446),
            new Point(1.3, 2.2817),
            new Point(1.7, 3.236),
            new Point(2.1, 4.6368)
    };


    static double[] linearCoeffs;
    static double[] quadraticCoeffs;

    public static void main(String[] args) {

        // Решаем МНК для 1-й степени
        linearCoeffs = solveLinearLeastSquares(points);
        System.out.println("Приближающий многочлен 1-й степени:");
        printPolynomial(linearCoeffs);
        System.out.printf("Сумма квадратов ошибок: %.6f\n\n", computeError(points, linearCoeffs));

        // Решаем МНК для 2-й степени
        quadraticCoeffs = solveQuadraticLeastSquares(points);
        System.out.println("Приближающий многочлен 2-й степени:");
        printPolynomial(quadraticCoeffs);
        System.out.printf("Сумма квадратов ошибок: %.6f\n", computeError(points, quadraticCoeffs));

        // Рисуем графики
        JFrame frame = new JFrame("График МНК");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(800, 600);
        frame.setContentPane(new Main());
        frame.setVisible(true);
    }

    // Метод для решения нормальной системы для 1-й степени
    public static double[] solveLinearLeastSquares(Point[] points) {
        int n = points.length;
        double sumX = 0, sumY = 0, sumX2 = 0, sumXY = 0;

        //по формуле составляем систему уравнений
        // a0*(N+1) + a1*sumX = sumY
        // a0*sumX + a1*sumX^2 = sumXY
        for (Point p : points) {
            sumX += p.x;
            sumY += p.y;
            sumX2 += p.x * p.x;
            sumXY += p.x * p.y;
        }

        //записываем систему в виде матрицы
        double[][] A = {
                {n, sumX},
                {sumX, sumX2}
        };
        double[] B = {sumY, sumXY};

        //решаем методом гаусса
        return gaussianElimination(A, B);
    }

    // Метод для решения нормальной системы для 2-й степени
    public static double[] solveQuadraticLeastSquares(Point[] points) {
        int n = points.length;
        double sumX = 0, sumY = 0, sumX2 = 0, sumX3 = 0, sumX4 = 0, sumXY = 0, sumX2Y = 0;

        //по формуле составляем систему уравнений
        // a0*(N+1) + a1*sumX + a2*sumX^2 = sumY
        // a0*sumX + a1*sumX^2 + a2*sumX^3 = sumXY
        // a0*sumX^2 + a1*sumX^3 + a2*sumX^4 = sumYX^2
        for (Point p : points) {
            double xi = p.x;
            double yi = p.y;
            double xi2 = xi * xi;
            double xi3 = xi2 * xi;
            double xi4 = xi3 * xi;

            sumX += xi;
            sumY += yi;
            sumX2 += xi2;
            sumX3 += xi3;
            sumX4 += xi4;
            sumXY += xi * yi;
            sumX2Y += xi2 * yi;
        }

        //составляем систему в виде матрицы
        double[][] A = {
                {n, sumX, sumX2},
                {sumX, sumX2, sumX3},
                {sumX2, sumX3, sumX4}
        };
        double[] B = {sumY, sumXY, sumX2Y};

        return gaussianElimination(A, B);
    }

    /*
     * Метод Гаусса для решения системы линейных уравнений
     * @param A - матрица коэффициентов (n x n)
     * @param B - вектор правых частей (n)
     * @return вектор решений (n)
     */
    public static double[] gaussianElimination(double[][] A, double[] B) {
        int n = B.length;

        // Прямой ход метода Гаусса (приведение к треугольному виду)
        for (int i = 0; i < n; i++) {
            // Поиск строки с максимальным элементом в текущем столбце
            int maxRow = i;
            for (int k = i + 1; k < n; k++) {
                if (Math.abs(A[k][i]) > Math.abs(A[maxRow][i])) {
                    maxRow = k;
                }
            }

            // Перестановка строк для улучшения устойчивости метода
            double[] tempRow = A[i];
            A[i] = A[maxRow];
            A[maxRow] = tempRow;

            double tempVal = B[i];
            B[i] = B[maxRow];
            B[maxRow] = tempVal;

            // Приведение матрицы (обнуление элементов под ведущим)
            for (int k = i + 1; k < n; k++) {
                // Вычисление множителя для текущей строки
                double factor = A[k][i] / A[i][i];

                // Вычитание текущей строки, умноженной на множитель
                for (int j = i; j < n; j++) {
                    A[k][j] -= factor * A[i][j];
                }
                B[k] -= factor * B[i];
            }
        }

        // Обратный ход метода Гаусса (нахождение решений)
        double[] x = new double[n];
        for (int i = n - 1; i >= 0; i--) {
            // Начинаем с правой части уравнения
            x[i] = B[i];

            // Вычитаем уже найденные решения
            for (int j = i + 1; j < n; j++) {
                x[i] -= A[i][j] * x[j];
            }

            // Деление на диагональный элемент для получения решения
            x[i] /= A[i][i];
        }

        return x;
    }

    // Вычисление суммы квадратов ошибок
    public static double computeError(Point[] points, double[] coeffs) {
        double error = 0;
        for (Point p : points) {
            double approx = 0;
            double xi = 1;
            for (double c : coeffs) {
                approx += c * xi;
                xi *= p.x;
            }
            error += Math.pow(p.y - approx, 2);
        }
        return error;
    }

    // Печать приближающего многочлена
    public static void printPolynomial(double[] coeffs) {
        for (int i = 0; i < coeffs.length; i++) {
            System.out.printf("%s%.6f·x^%d", (i > 0 ? " + " : ""), coeffs[i], i);
        }
        System.out.println();
    }

    // Основной метод отрисовки компонента
    @Override
    protected void paintComponent(Graphics g) {
        // Вызываем родительский метод для правильной подготовки графического контекста
        super.paintComponent(g);

        // 1. Рисуем сетку координат
        drawGrid(g);

        // Создаем Graphics2D объект для более продвинутой графики
        Graphics2D g2 = (Graphics2D) g;

        // Устанавливаем толщину линии для всех последующих рисований
        g2.setStroke(new BasicStroke(2));

        // 2. Рисуем кривые приближения:
        // - Квадратичную аппроксимацию (красным цветом)
        drawCurve(g2, quadraticCoeffs, Color.RED);
        // - Линейную аппроксимацию (синим цветом)
        drawCurve(g2, linearCoeffs, Color.BLUE);

        // 3. Рисуем исходные точки данных (черным цветом)
        drawPoints(g2, points, Color.BLACK);
    }

    /*
     * Метод для рисования координатной сетки
     * @param g - графический контекст
     */
    private void drawGrid(Graphics g) {
        // Устанавливаем цвет сетки - светло-серый
        g.setColor(Color.LIGHT_GRAY);

        // Рисуем вертикальные линии сетки с шагом 50 пикселей
        for (int x = 0; x <= getWidth(); x += 50) {
            g.drawLine(x, 0, x, getHeight());
        }

        // Рисуем горизонтальные линии сетки с шагом 50 пикселей
        for (int y = 0; y <= getHeight(); y += 50) {
            g.drawLine(0, y, getWidth(), y);
        }
    }

    /*
     * Метод для рисования точек данных
     * @param g - графический контекст (Graphics2D)
     * @param pts - массив точек для отрисовки
     * @param color - цвет точек
     */
    private void drawPoints(Graphics2D g, Point[] pts, Color color) {
        // Устанавливаем цвет точек
        g.setColor(color);

        // Перебираем все точки в массиве
        for (Point p : pts) {
            // Преобразуем координаты точки в экранные координаты
            int x = scaleX(p.x);
            int y = scaleY(p.y);

            // Рисуем закрашенный круг (точку) радиусом 4 пикселя
            g.fillOval(x - 4, y - 4, 8, 8);
        }
    }

    /*
     * Метод для рисования кривой аппроксимации
     * @param g - графический контекст (Graphics2D)
     * @param coeffs - коэффициенты полинома
     * @param color - цвет кривой
     */
    private void drawCurve(Graphics2D g, double[] coeffs, Color color) {
        // Устанавливаем цвет кривой
        g.setColor(color);

        // Список для хранения точек кривой
        List<Point> curve = new ArrayList<>();

        // Генерируем точки кривой с шагом 0.01 по оси X
        for (double x = 0.0; x <= 2.2; x += 0.01) {
            double y = 0;  // Начальное значение Y
            double xi = 1; // x^0 = 1

            // Вычисляем значение полинома для текущего x
            for (double c : coeffs) {
                y += c * xi;  // Добавляем очередной член полинома
                xi *= x;      // Увеличиваем степень x для следующего члена
            }

            // Добавляем вычисленную точку в список
            curve.add(new Point(x, y));
        }

        // Рисуем кривую как последовательность соединенных отрезков
        for (int i = 1; i < curve.size(); i++) {
            // Получаем предыдущую и текущую точки
            Point prev = curve.get(i - 1);
            Point curr = curve.get(i);

            // Преобразуем координаты в экранные
            int x1 = scaleX(prev.x);
            int y1 = scaleY(prev.y);
            int x2 = scaleX(curr.x);
            int y2 = scaleY(curr.y);

            // Рисуем отрезок между точками
            g.drawLine(x1, y1, x2, y2);
        }
    }

    /*
     * Преобразование координаты X из математической системы в экранные координаты
     * @param x - значение по оси X в математических координатах
     * @return экранная координата X
     */
    private int scaleX(double x) {
        // Формула преобразования: x * 20 + 400
        // - 20 - масштабный коэффициент (пикселей на единицу)
        // - 400 - смещение по оси X (чтобы график был не у края)
        return (int) (x * 20 + 400);
    }

    /*
     * Преобразование координаты Y из математической системы в экранные координаты
     * @param y - значение по оси Y в математических координатах
     * @return экранная координата Y
     */
    private int scaleY(double y) {
        // Формула преобразования: y * 10 + 150
        // - 10 - масштабный коэффициент (пикселей на единицу)
        // - 150 - смещение по оси Y (чтобы график был не у верхнего края)
        // Обратите внимание: ось Y в экранных координатах направлена вниз,
        // поэтому не нужно инвертировать знак
        return (int) (y * 10 + 150);
    }
}
